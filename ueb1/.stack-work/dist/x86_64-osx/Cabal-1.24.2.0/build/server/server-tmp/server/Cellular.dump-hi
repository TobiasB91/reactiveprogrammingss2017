
==================== FINAL INTERFACE ====================
2017-04-26 15:11:05.798779 UTC

interface main@main:Cellular 8002
  interface hash: 878543e81d5890c39a11a14bef555a95
  ABI hash: ff12a2863189530591cdbf2375f06977
  export-list hash: 29f1cfb17af1e1e0415bc750f3177fc3
  orphan hash: 2e18c83afba0e005e8fafd443c6580c2
  flag hash: bed2c2d4d9fda7d0eab85a3d8ef83f31
  sig of: Nothing
  used TH splices: False
  where
exports:
  Cellular.dead
  Cellular.runCA
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      containers-0.5.7.1@containers-0.5.7.1*
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog*
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base 8b155a212edaca6c85bcefe65a8bc505
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Strict f81ee5f2f6ed64270eb463b87b6da821
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Lazy 3bce07487954e2c74715e207af0f6091
import  -/  random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog:System.Random cc3ef358c669b194cf9fe94db6f2430f
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Class 45530f1305724ee3931a9be21b40ca7e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
6291e4238702418e9d17e430ef0aeb08
  $fEqStatus :: GHC.Classes.Eq Cellular.Status
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Cellular.Status
                  Cellular.$fEqStatus_$c==
                  Cellular.$fEqStatus_$c/= -}
6291e4238702418e9d17e430ef0aeb08
  $fEqStatus_$c/= ::
    Cellular.Status -> Cellular.Status -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Cellular.Status) (b :: Cellular.Status) ->
                 case a of wild {
                   Cellular.Alive
                   -> case b of wild1 {
                        Cellular.Alive -> GHC.Types.False Cellular.Dead -> GHC.Types.True }
                   Cellular.Dead
                   -> case b of wild1 {
                        Cellular.Alive -> GHC.Types.True
                        Cellular.Dead -> GHC.Types.False } }) -}
6291e4238702418e9d17e430ef0aeb08
  $fEqStatus_$c== ::
    Cellular.Status -> Cellular.Status -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Cellular.Status) (ds1 :: Cellular.Status) ->
                 case ds of wild {
                   Cellular.Alive
                   -> case ds1 of wild1 {
                        Cellular.Alive -> GHC.Types.True Cellular.Dead -> GHC.Types.False }
                   Cellular.Dead
                   -> case ds1 of wild1 {
                        Cellular.Alive -> GHC.Types.False
                        Cellular.Dead -> GHC.Types.True } }) -}
6291e4238702418e9d17e430ef0aeb08
  $fShowStatus :: GHC.Show.Show Cellular.Status
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Cellular.Status
                  Cellular.$fShowStatus_$cshowsPrec
                  Cellular.$fShowStatus_$cshow
                  Cellular.$fShowStatus_$cshowList -}
6291e4238702418e9d17e430ef0aeb08
  $fShowStatus1 :: Cellular.Status -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Cellular.Status) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Cellular.Alive
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Cellular.$fShowStatus3)
                        eta
                   Cellular.Dead
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Cellular.$fShowStatus2)
                        eta }) -}
994e3633e2b375bf0e69953557eabc5b
  $fShowStatus2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Dead"#) -}
c29f02f1293b19b4b8c16d71fd8da381
  $fShowStatus3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Alive"#) -}
6291e4238702418e9d17e430ef0aeb08
  $fShowStatus_$cshow :: Cellular.Status -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Cellular.Status) ->
                 case x of wild {
                   Cellular.Alive -> Cellular.$fShowStatus3
                   Cellular.Dead -> Cellular.$fShowStatus2 }) -}
6291e4238702418e9d17e430ef0aeb08
  $fShowStatus_$cshowList :: [Cellular.Status] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Cellular.Status
                   Cellular.$fShowStatus1) -}
6291e4238702418e9d17e430ef0aeb08
  $fShowStatus_$cshowsPrec ::
    GHC.Types.Int -> Cellular.Status -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Cellular.Status)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Cellular.Alive
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Cellular.$fShowStatus3)
                        eta
                   Cellular.Dead
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Cellular.$fShowStatus2)
                        eta }) -}
bdb3b9f5135a673ce4f06c5b02cfecae
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     Cellular.$s$fEq(,)_$dEq
                     Cellular.$s$fEq(,)_$dEq)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     Cellular.$s$fEq(,)_$dEq
                     Cellular.$s$fEq(,)_$dEq) -}
a9387702267cce3555e34653cbb53036
  $s$fEq(,)1 ::
    GHC.Classes.Eq ((GHC.Types.Int, GHC.Types.Int), Cellular.Status)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ((GHC.Types.Int, GHC.Types.Int), Cellular.Status)
                  (GHC.Classes.$fEq(,)_$c==
                     @ (GHC.Types.Int, GHC.Types.Int)
                     @ Cellular.Status
                     Cellular.$s$fEq(,)2
                     Cellular.$fEqStatus)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ (GHC.Types.Int, GHC.Types.Int)
                     @ Cellular.Status
                     Cellular.$s$fEq(,)2
                     Cellular.$fEqStatus) -}
1a6b72674f8f6b34b6429c24307ccac0
  $s$fEq(,)2 :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Cellular.$s$fEq(,) -}
ceed525efdecb33e9401ec82ba95fcdf
  $s$fEq(,)_$dEq :: GHC.Classes.Eq GHC.Types.Int
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) GHC.Classes.$fEqInt -}
5b7713074051fd0861531cf1f6536fe1
  $s$fOrd(,) :: GHC.Classes.Ord (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  Cellular.$s$fEq(,)2
                  (GHC.Classes.$fOrd(,)_$ccompare
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fOrdInt
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c<
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fOrdInt
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c<=
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fOrdInt
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c>
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fOrdInt
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c>=
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fOrdInt
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$cmax
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fOrdInt
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$cmin
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fOrdInt
                     GHC.Classes.$fOrdInt) -}
a34cebf1e346611d6e33201055f11320
  $sfromList ::
    [((GHC.Types.Int, GHC.Types.Int), a)]
    -> Data.Map.Base.Map (GHC.Types.Int, GHC.Types.Int) a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [((GHC.Types.Int, GHC.Types.Int), a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ (GHC.Types.Int, GHC.Types.Int) @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case x of x1 { DEFAULT ->
                           case kx of dt { (,) ipv ipv1 ->
                           Data.Map.Base.Bin
                             @ (GHC.Types.Int, GHC.Types.Int)
                             @ a
                             1#
                             dt
                             x1
                             (Data.Map.Base.Tip @ (GHC.Types.Int, GHC.Types.Int) @ a)
                             (Data.Map.Base.Tip @ (GHC.Types.Int, GHC.Types.Int) @ a) } }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case kx of ww { (,) ww1 ww2 ->
                           case ky of ww3 { (,) ww4 ww5 ->
                           case ww1 of wild4 { GHC.Types.I# x# ->
                           case ww4 of wild5 { GHC.Types.I# y# ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# x# y#) of wild6 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x# y#) of wild7 {
                                  GHC.Types.False
                                  -> case x of x0 { DEFAULT ->
                                     Cellular.$sfromList1
                                       @ a
                                       (Data.Map.Base.Bin
                                          @ (GHC.Types.Int, GHC.Types.Int)
                                          @ a
                                          1#
                                          ww
                                          x0
                                          (Data.Map.Base.Tip @ (GHC.Types.Int, GHC.Types.Int) @ a)
                                          (Data.Map.Base.Tip @ (GHC.Types.Int, GHC.Types.Int) @ a))
                                       wild2 }
                                  GHC.Types.True
                                  -> case ww2 of wild8 { GHC.Types.I# x1 ->
                                     case ww5 of wild9 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.>=# x1 y) of wild10 {
                                       GHC.Types.False
                                       -> case x of x0 { DEFAULT ->
                                          Cellular.$wpoly_go4
                                            @ a
                                            1#
                                            (Data.Map.Base.Bin
                                               @ (GHC.Types.Int, GHC.Types.Int)
                                               @ a
                                               1#
                                               ww
                                               x0
                                               (Data.Map.Base.Tip
                                                  @ (GHC.Types.Int, GHC.Types.Int)
                                                  @ a)
                                               (Data.Map.Base.Tip
                                                  @ (GHC.Types.Int, GHC.Types.Int)
                                                  @ a))
                                            wild2 }
                                       GHC.Types.True
                                       -> case x of x0 { DEFAULT ->
                                          Cellular.$sfromList1
                                            @ a
                                            (Data.Map.Base.Bin
                                               @ (GHC.Types.Int, GHC.Types.Int)
                                               @ a
                                               1#
                                               ww
                                               x0
                                               (Data.Map.Base.Tip
                                                  @ (GHC.Types.Int, GHC.Types.Int)
                                                  @ a)
                                               (Data.Map.Base.Tip
                                                  @ (GHC.Types.Int, GHC.Types.Int)
                                                  @ a))
                                            wild2 } } } } }
                             GHC.Types.True
                             -> case x of x0 { DEFAULT ->
                                Cellular.$wpoly_go4
                                  @ a
                                  1#
                                  (Data.Map.Base.Bin
                                     @ (GHC.Types.Int, GHC.Types.Int)
                                     @ a
                                     1#
                                     ww
                                     x0
                                     (Data.Map.Base.Tip @ (GHC.Types.Int, GHC.Types.Int) @ a)
                                     (Data.Map.Base.Tip @ (GHC.Types.Int, GHC.Types.Int) @ a))
                                  wild2 } } } } } } } } } }) -}
8c3e2d66346c3c5e4b31a76d1d86c5b7
  $sfromList1 ::
    Data.Map.Base.Map (GHC.Types.Int, GHC.Types.Int) a1
    -> [((GHC.Types.Int, GHC.Types.Int), a1)]
    -> Data.Map.Base.Map (GHC.Types.Int, GHC.Types.Int) a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
41adb146c6d356c1e310bb4dd4e3cab4
  $sinsert_go4 ::
    GHC.Classes.Ord k1 =>
    k1 -> a1 -> Data.Map.Base.Map k1 a1 -> Data.Map.Base.Map k1 a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U><S,1*U> -}
7e6149a94eb77f9a390d6d6e4c20753a
  $slookup1 ::
    Cellular.Cell
    -> Data.Map.Base.Map Cellular.Cell a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U(U),U(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Cellular.Cell)
                   (w1 :: Data.Map.Base.Map Cellular.Cell a) ->
                 case w of ww { (,) ww1 ww2 ->
                 Cellular.$wpoly_go10 @ a ww1 ww2 w1 }) -}
723e642b4406c66a9afef4d595340dbb
  $tc'Alive :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5734059461202412297##
                   6162379739068140723##
                   Cellular.$trModule
                   Cellular.$tc'Alive1) -}
d5b4ed3c321c4ab1fa5a2421196f7a92
  $tc'Alive1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Alive"#) -}
636d10aced8286c29411e0aacddf00f3
  $tc'Dead :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6401029709587337163##
                   15416334524795350137##
                   Cellular.$trModule
                   Cellular.$tc'Dead1) -}
c283d8696aa45cd5caeb3f6595444b45
  $tc'Dead1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Dead"#) -}
06708646a2bddc725c94ab3caac49a08
  $tcStatus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8322387872672262683##
                   16973376357352293328##
                   Cellular.$trModule
                   Cellular.$tcStatus1) -}
53e274bf7b8be4194ac78cae780c08b5
  $tcStatus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Status"#) -}
fcd3426679309a683430abb1a8f40cba
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Cellular.$trModule2
                   Cellular.$trModule1) -}
dacbe9a11900130464d6f6f271a74f72
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Cellular"#) -}
4d2d802f0ae080e2e8a8d2071f94b379
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
868569e326915e0feb1a3bbe015d9712
  $wpoly_go10 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Map.Base.Map Cellular.Cell a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U)><L,U(U)><S,1*U>,
     Inline: [0] -}
08aded52bf87c71ce77313ff8ec3ec60
  $wpoly_go4 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map (GHC.Types.Int, GHC.Types.Int) a
    -> [((GHC.Types.Int, GHC.Types.Int), a)]
    -> Data.Map.Base.Map (GHC.Types.Int, GHC.Types.Int) a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
86654311b4db97a8b64277a5a466eb64
  type Board = Data.Map.Base.Map Cellular.Cell Cellular.Status
69beee80d9e3dce27ccb54dadf6c71e1
  type CA a =
    Control.Monad.Trans.State.Lazy.StateT Cellular.Board GHC.Types.IO a
2dfa6e670578c7d81fd26add37e79845
  type Cell = (GHC.Types.Int, GHC.Types.Int)
654928b41cc67da3656d483bf0930517
  type Rule = Cellular.Cell -> Cellular.Board -> Cellular.Status
6291e4238702418e9d17e430ef0aeb08
  data Status = Alive | Dead
11739c9a5bfae88ed9a10c95e1eacb7f
  dead :: Cellular.Cell -> Cellular.Board -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U(U),U(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (c :: Cellular.Cell) (m :: Cellular.Board) ->
                 case Cellular.$slookup1 @ Cellular.Status c m of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just ds
                   -> case ds of wild1 {
                        Cellular.Alive -> GHC.Types.False
                        Cellular.Dead -> GHC.Types.True } }) -}
e0821d595f5dae612bb876cd383dd172
  runCA :: GHC.Types.Int -> GHC.Types.IO Cellular.Board
  {- Arity: 2, Strictness: <L,U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Cellular.runCA1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Cellular.Board>_R)) -}
e9d8464eeeef44bb7a7b6dc54b6d2af5
  runCA1 ::
    GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Cellular.Board #)
  {- Arity: 2, Strictness: <L,U(U)><S,U> -}
instance [safe] GHC.Classes.Eq [Cellular.Status]
  = Cellular.$fEqStatus
instance [safe] GHC.Show.Show [Cellular.Status]
  = Cellular.$fShowStatus
"SPEC/Cellular $fEq(,) @ (Int, Int) @ Status" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                          Cellular.Status)
                                                              ($dEq :: GHC.Classes.Eq
                                                                         (GHC.Types.Int,
                                                                          GHC.Types.Int))
  GHC.Classes.$fEq(,) @ (GHC.Types.Int, GHC.Types.Int)
                      @ Cellular.Status
                      $dEq
                      $dEq1
  = Cellular.$s$fEq(,)1
"SPEC/Cellular $fEq(,) @ Int @ Int" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                GHC.Types.Int)
                                                    ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Cellular.$s$fEq(,)
"SPEC/Cellular $fOrd(,) @ Int @ Int" [ALWAYS] forall ($dOrd1 :: GHC.Classes.Ord
                                                                  GHC.Types.Int)
                                                     ($dOrd :: GHC.Classes.Ord GHC.Types.Int)
  GHC.Classes.$fOrd(,) @ GHC.Types.Int @ GHC.Types.Int $dOrd $dOrd1
  = Cellular.$s$fOrd(,)
"SPEC/Cellular fromList @ (Int, Int) _" [ALWAYS] forall @ a
                                                        ($dOrd :: GHC.Classes.Ord
                                                                    (GHC.Types.Int, GHC.Types.Int))
  Data.Map.Strict.fromList @ (GHC.Types.Int, GHC.Types.Int) @ a $dOrd
  = Cellular.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

